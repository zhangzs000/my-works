<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
  var arr = [2,9,9,8,7,8,8,8,6,5,4,3,4]
  function HeapSort (A, n) {
	var heap_size = BuildHeap(A, n);    
    // 建立一个最大堆
    while (heap_size > 1) {  　　　　　　 
    // 堆（无序区）元素个数大于1，未完成排序
    
        // 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素
        // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法
        Swap(A, 0, --heap_size);
        Heapify(A, 0, heap_size);     // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)
    }
	    return A
}
function BuildHeap(A, n) {          
    // 建堆，时间复杂度O(n)
    
        var heap_size = n;
        // Math.floor要不然第一次就没有对应的数据
        for (var i = Math.floor(heap_size / 2) - 1; i >= 0; i--) // 从每一个非叶结点开始向下进行堆调整
            Heapify(A, i, heap_size);
        return heap_size;
    }
function Heapify(A, i, size){ 
    // 从A[i]向下进行堆调整
    var left_child = 2 * i + 1;         // 左孩子索引
   var right_child = 2 * i + 2;        // 右孩子索引
    var max = i;                        // 选出当前结点与其左右孩子三者之中的最大值
    if (left_child < size && A[left_child] > A[max])
        max = left_child;
    if (right_child < size && A[right_child] > A[max])
        max = right_child;
    if (max != i)
    {
        Swap(A, i, max);                // 把当前结点和它的最大(直接)子节点进行交换
        Heapify(A, max, size);          // 递归调用，继续从当前结点向下进行堆调整
    }
}
function Swap(A, i, j){
    var temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
console.log(HeapSort(arr, arr.length))
  </script>
</body>
</html>